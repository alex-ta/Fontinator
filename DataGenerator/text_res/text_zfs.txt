ZFS ist ein von Sun Microsystems entwickeltes transaktionales Dateisystem, das zahlreiche Erweiterungen für die Verwendung im Server- und Rechenzentrumsbereich enthält. Hierzu zählen die enorme maximale Dateisystemgröße, eine einfache Verwaltung selbst komplexer Konfigurationen, die integrierten RAID-Funktionalitäten, das Volume-Management sowie der prüfsummenbasierte Schutz vor Datenübertragungsfehlern. Der Name ZFS stand ursprünglich für Zettabyte File System, ist aber inzwischen ein Pseudo-Akronym, wodurch die Langform nicht mehr gebräuchlich ist.
Eigenschaften
ZFS ist ein 128-Bit Copy-On-Write-Dateisystem mit einer im Vergleich zu herkömmlichen Dateisystemen deutlich erweiterten Funktionalität. Bei herkömmlichen Dateisystemen verwaltet genau ein Dateisystem genau eine Partition. Sollen mehrere physische Partitionen zu logischen Partitionen zusammengefasst werden, muss hierzu eine zusätzliche Logical Volume Manager Software installiert werden. Zur Ausfallsicherung können viele Dateisysteme zusätzlich durch ein optionales softwarebasiertes RAID-Subsystem (Software-RAID) abgesichert werden. ZFS fasst diese drei Funktionen zusammen und ergänzt diese um einen prüfsummenbasierten Schutz vor Datenübertragungsfehlern.
Datenträger-Pools
In der Praxis werden zunächst aus physischen Datenträgern (eigentlich Datenspeicher-Geräten) logische Einheiten – so genannte Pools (bzw. zPools) – gebildet, welche optional auch ausfallsicher ausgelegt sein können (RAID). Innerhalb eines Pools können dann beliebig viele logische Partitionen (mit je einem Dateisystem) angelegt werden, wobei diese, soweit es die Größe des Pools zulässt, dynamisch wachsen, aber auch verkleinert werden können. Um administrative Einschränkungen durchzusetzen, kann für jede logische Partition eine minimale und maximale Größe vorgegeben werden. Die logischen Partitionen können dabei in eine hierarchische Struktur eingebettet werden, innerhalb derer diese und andere Parameter auch vererbt werden können. Weiterhin ist es möglich, Datenbereiche aus Pools als dezidierte „Block-Devices“ (siehe auch Datenblock-orientierte Geräte) zur Verfügung zu stellen.
Die zweite Besonderheit von ZFS ist die besonders einfache Administration. Um einen Pool über mehrere Festplatten zu erzeugen und auf diesem eine Partition anzulegen, werden lediglich zwei einfach strukturierte Befehle benötigt. Das Partitionieren, Aufbauen des logischen Volumens und schließlich das Einhängen ins bestehende Dateisystem werden automatisch erledigt, können aber bei Bedarf auch manuell vorgenommen werden.
Ausfallsicherheit
Redundanz
Wie bei einem klassischen Volume-Manager können die zugrunde liegenden Pools ausfallsicher angelegt sein. Hierzu werden aus mehreren physischen Datenträgern per Software-RAID sogenannte Redundanz-Gruppen gebildet, eine oder mehrere dieser redundanten Gruppen bilden dann einen ausfallsicheren Pool. Das in das Dateisystem integrierte RAID-Subsystem bietet gegenüber klassischen Hardware- oder Software-Raid-Implementierungen den Vorteil, dass zwischen belegten und freien Datenblöcken unterschieden werden kann und somit bei der Rekonstruktion eines Raid-Volumens nur belegter Plattenplatz gespiegelt werden muss, hieraus resultiert im Schadensfall, besonders bei wenig gefüllten Dateisystemen, eine enorme Zeitersparnis. ZFS stellt mehrere RAID-Level zur Auswahl. Bei der Spiegelung (RAID-1) bilden zwei (oder mehr) Festplatten eine gespiegelte Redundanz-Gruppe, wobei die Daten zweimal oder öfter gespeichert werden können. Weiter gibt es zwei RAID-Z genannte Implementierungen. RAID-Z1 arbeitet ähnlich wie RAID-5, RAID-Z2 entspricht weitestgehend RAID 6. Bei RAID-Z1 bilden drei (oder mehr) Festplatten die Redundanz-Gruppe, dabei sind die Daten wie bei einem RAID 5 System paritätsgesichert, so dass eine der Festplatten ausfallen kann, ohne dass dabei Datenverluste entstehen. Durch das integrierte Design des ZFS wird jedoch im Gegensatz zu RAID-5 kein batteriegepufferter Speicher (NVRAM) benötigt, da keine Schreiblücke (write hole) zwischen Daten-Schreiben und Parity-Schreiben auftritt. Die RAID-Z2 genannte, ebenfalls schreiblückenfreie Implementierung von RAID-6 ist seit Solaris Express 47 verfügbar. Seit Juli 2009 ist auch RAID-Z3, also eine RAID-Z-Implementierung mit 3 Paritätsbits, verfügbar.[3] Die Geschwindigkeitsoptimierung durch parallelen Zugriff (RAID-0 – Striping) wird von ZFS automatisch vorgenommen.
Snapshots
Copy-On-Write erlaubt es, sehr effizient Snapshots zu erstellen, dies geschieht praktisch sofort und das Dateisystem bleibt online. Ein Snapshot friert den aktuellen Dateisystemzustand ein, darauf folgende Schreiboperationen repräsentieren jeweils die Differenzen zum letzten Snapshot. ZFS-Snapshots können zum Lesen gemountet oder auch archiviert (zfs send) werden, des Weiteren gibt es ZFS-Clones, diese entsprechen einem beschreibbaren Snapshot.[4]
Automatische Datenfehlerkorrektur
Neben den Möglichkeiten, Daten gegen Festplattenausfälle zu sichern, wird außerdem jeder einzelne Block im Dateisystem mit einer Prüfsumme versehen, sodass Datenfehler im Dateisystem (z. B. verursacht durch Datenübertragungsfehler) automatisch erkannt und ggf. ohne manuellen Eingriff behoben werden können. Der Performance-Verlust ist dabei minimal. Auch stellt ZFS sicher, dass der Zustand des Dateisystems zu jeder Zeit konsistent ist und deshalb auch beispielsweise nach einem Stromausfall kein Überprüfen des Dateisystems (per fsck) notwendig ist.
Deduplikation
Im Oktober 2009 wurde Deduplikation für ZFS freigegeben.[5] Dadurch werden Blöcke mit identischem Inhalt nur noch einmal physisch abgelegt, was hilft Plattenplatz zu sparen. Ein typischer Anwendungsfall ist das Anlegen von virtuellen Festplatten für virtuelle Maschinen, die jeweils alle eine Installation eines virtualisierten Betriebssystems enthalten. Eine weitere wäre aus gleichartigen Backups redundante Information zu entfernen. Deduplikation benötigt allerdings viel RAM, wodurch ZFS bei Nutzung als resourcenhungrig bezeichnet wurde. In OpenZFS bietet sich daher eher die LZ4 Kompression an, die eher auf Geschwindigkeit als auf Kompression ausgelegt ist und keinen zusätzlichen Speicher benötigt.
Performance
Weiterhin ist ZFS ein relativ schnelles Dateisystem; aufgrund der integrierten RAID-Funktionen und End-To-End-Checksummen kommt es jedoch in der Geschwindigkeit auf älteren bzw. langsameren Systemen nicht an einfachere Dateisysteme heran, wobei die Performance von ZFS auch davon abhängig ist, welche RAID-Funktionalität genutzt wird und ob die einzelnen Platten unabhängig voneinander und gleichzeitig Daten transferieren können.
Datenkapazität
ZFS ist für sehr große Datenmengen ausgelegt, was durch die durchgängige Verwendung von 128-Bit-Zeigern erreicht wird. In der Praxis sind die Grenzen jedoch mit denen eines 64-Bit-Dateisystems vergleichbar. Bei der Implementation unter Solaris und beispielsweise auch FreeBSD werden 64-Bit-Datentypen verwendet, da es in C derzeit keine architektur- und compilerübergreifend nutzbaren 128-Bit-Datentypen gibt. Im Wesentlichen werden die ersten 64 Bits des Zeigers immer zusammen mit 64 Nullen abgespeichert, die bei der Verarbeitung ignoriert werden. Das ermöglicht es, bestehende Dateisysteme später als echte 128-Bit-Dateisysteme weiterhin verwenden zu können. Die Kapazität von ZFS ist so ausgelegt, dass sie für immer ausreicht.
Bei einer vollen Ausnutzung der 128 Bit entspräche die theoretische maximale Kapazität 281 Billionen YiB.
Entwicklung
Sun hat das ZFS für Solaris 10 entwickelt und stellt es auch unter der Common Development and Distribution License (CDDL) für OpenSolaris (ab Build 27a) bereit. Seit Solaris 10 6/06 besteht offiziell Support für ZFS. ZFS ist sowohl für Solaris auf SPARC als auch auf x86/x64 verfügbar. Entworfen und umgesetzt wurde das Projekt vom Sun-Team unter der Leitung von Jeff Bonwick.
ZFS wurde von Pawel Jakub Dawidek mit Unterstützung durch Sun-Entwickler auf FreeBSD portiert[6] und ist seit FreeBSD 7.0 im Basissystem enthalten, wurde damals aber noch als experimentell eingestuft. Dies hat sich erst mit der Version 8.0 geändert.[7]
Auch Apple hatte ZFS-Unterstützung in Mac-OS-X-Version (10.5 Leopard) integriert, wenn auch nur lesend. Eine Implementierung war für die Version Snow Leopard Server angekündigt worden, wurde jedoch nicht veröffentlicht. Stattdessen wurden auf Apples Open-Source-Projektseite Mac OS Forge Quelltext und Binärprogramme der ZFS-Portierung veröffentlicht. Am 23. Oktober 2009 gab Apple dort bekannt, dass das ZFS-Projekt eingestellt wurde.[8] Seit September 2012 gibt es eine ZFS-Implementierung für OS X von der Firma GreenBytes.[9]
Eine direkte Unterstützung innerhalb des Linux-Kernels ist aus Lizenzgründen problematisch, daher gibt es momentan keine direkt in die Kernelsourcen integrierte Linux-Implementierung. Allerdings gibt es das Projekt ZFS on FUSE, das ZFS auch unter Linux nutzbar macht.[10] Am 9. März 2011 erschien ZFS on FUSE in Version 0.7.0.[11] Die Implementierung im Userspace hat verschiedene Nachteile, unter anderem einen verminderten Datendurchsatz. Ein alternativer Lösungsansatz namens ZFS on Linux,[12] bei dem die nötigen Kernel-Module außerhalb des Kernel-Quellbaums gepflegt werden, ist nach Aussagen der Entwickler seit der im April 2013 veröffentlichen Version 0.6.1 reif für den produktiven Einsatz.[13]
Nach der Übernahme von Sun durch Oracle (in den Jahren 2009 bis 2010) wurden zahlreiche unabhängige Entwicklungen des ZFS fortgeführt. Im September 2013 wurde schließlich damit begonnen, all diese unabhängigen Entwicklungen in einem Projekt mit der Bezeichnung OpenZFS wieder zusammenzuführen. Dabei soll das Dateisystem dann unter anderem auch betriebssystemübergreifend vereinheitlicht werden.[14][15]
Kritik
ZFS wurde für den Server- und Rechenzentrumseinsatz konzipiert und sammelt dort seine Pluspunkte, daraus ergeben sich teilweise Nachteile beim Einsatz auf Arbeitsplatzrechnern und eingebetteten Systemen.
Die Verarbeitung der 128-Bit-Pointer (siehe Eigenschaften) ist vergleichsweise aufwändig, da sie nicht der Wortbreite aktueller CPUs entspricht, die typischerweise bei 32 Bit im Bereich Appliances und älterer Personal Computer sowie bei 64 Bit im Bereich aktueller Einzelplatzrechner und den meisten Servern liegt. Somit ist auf derartigen Systemen keine optimale Performance gegeben. Überhaupt bringt die 128-Bit-Auslegung nur dort Vorteile, wo ungewöhnlich große Datenmengen gespeichert werden sollen. Im SOHO-Bereich hingegen sind je nach Datenträgergröße 32- oder 64-Bit-basierte Dateisysteme bezüglich der ablegbaren Datenmengen ausreichend (vergl. Btrfs, Ext2, FAT32, HFS+, NTFS, UFS usw.), die üblicherweise schon unter Verwendung von 32-Bit-Datentypen Dateisysteme mit einer Kapazität von knapp 16 Terabyte (z. B. ext2) verwalten können, bei 64-Bit-Pointern natürlich weitaus mehr, beispielsweise ca. 8 Exabyte (8 Millionen Terabyte) bei XFS. Die 128-Bit-Auslegung bedeutet hier also nur zusätzlichen Rechen- und Zeitaufwand sowie einen etwas erhöhten Platzbedarf auf dem Medium.
ZFS nutzt Copy-On-Write und ein ZIL (ZFS Intent Log). ZFS kann so zu jeder Zeit auf ein konsistentes Dateisystem zurückgreifen. Sicherungen und Rücksicherungen von Blöcken, sowie Dateisystemprüfungen sind so bei Abbrüchen wie einem Stromausfall nicht nötig. Inkonsistenzen in Metadaten und Daten werden bei jedem Lesevorgang automatisch erkannt und bei redundanter Information soweit möglich automatisch korrigiert. Die Performance von solchen Dateisystemen nimmt allerdings ab ca. 80 % Belegung spürbar ab, wie bei allen anderen Filesystemen auch.
Trivia
Zur theoretischen Kapazität von ZFS kursiert folgendes Zitat:
“Populating 128-bit file systems would exceed the quantum limits of earth-based storage. You couldn't fill a 128-bit storage pool without boiling the oceans.”
„Ein 128-Bit-Dateisystem zu füllen würde die quantenmechanische Grenze irdischer Datenspeicherung übersteigen. Man könnte einen 128-Bit-Speicher-Pool nicht füllen, ohne die Ozeane zu verdampfen.“
– Jeff Bonwick, Chefentwickler von ZFS
Zum Verständnis des Zitats sei angemerkt, dass die Speicherung oder Übertragung einer Informationseinheit – z. B. ein Bit – an die Speicherung oder Übertragung von Energie gekoppelt ist, da Information ohne ein Medium nicht existieren kann, d. h. Information ist an die Existenz unterscheidbarer Zustände gekoppelt. Die Gesetze der Quantenmechanik erzwingen eine Mindestmenge von Energie pro Informationseinheit, da die Information sonst aufgrund der quantenmechanischen Unschärfe verlorengeht. Um einen Speicherpool mit 128-Bit-Adressierung zu füllen, wäre eine Energiemenge notwendig, die größer ist als die Menge an Energie, die ausreichen würde, um die irdischen Ozeane zu verdampfen. Gleichzeitig ist „boiling the ocean“ im Englischen ein idiomatischer Ausdruck dafür, etwas Unmögliches zu versuchen. Bonwick illustriert damit, dass ZFS für alle Zukunft genügend Kapazität bietet.